# Deploy the audio-extract service to staging or production
#
# This workflow:
# - Automatically deploys to staging after successful builds on main/master
# - Supports manual deployment to staging or production
# - Performs health checks after deployment
# - Handles rollback on failure
#
# Required secrets:
# - STAGING_HOST, STAGING_USER, STAGING_SSH_KEY
# - PRODUCTION_HOST, PRODUCTION_USER, PRODUCTION_SSH_KEY
# - GCS_BUCKET_NAME, AUDIO_EXTRACT_FOLDER_ID (for production)

name: Deploy Audio Extract

on:
  workflow_run:
    workflows: ["Build Audio Extract"]
    types:
      - completed
    branches: [main, master]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: 'Docker image tag to deploy (e.g., latest, v1.2.3, sha-abc123)'
        required: false
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/audio-extract

jobs:
  deploy-staging:
    # Deploy to staging on:
    # - Successful builds from main/master
    # - Manual workflow dispatch with staging environment
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    runs-on: ubuntu-latest
    environment: staging
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set image tag
      id: set-tag
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Use the provided tag for manual deployments
          echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        else
          # For automatic deployments, use the SHA from the build workflow
          echo "tag=sha-${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
        fi
    
    - name: Deploy to staging
      env:
        DEPLOY_HOST: ${{ secrets.STAGING_HOST }}
        DEPLOY_USER: ${{ secrets.STAGING_USER }}
        DEPLOY_KEY: ${{ secrets.STAGING_SSH_KEY }}
        IMAGE_TAG: ${{ steps.set-tag.outputs.tag }}
      run: |
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts
        
        # Deploy script
        ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST << EOF
          set -e
          cd /opt/audio-extract
          
          # Pull latest config
          git pull origin main
          
          # Set the full image reference
          export AUDIO_EXTRACT_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.tag }}"
          echo "Deploying image: \${AUDIO_EXTRACT_IMAGE}"
          
          # Pull new image
          docker pull \${AUDIO_EXTRACT_IMAGE}
          
          # Deploy with zero downtime
          docker-compose -f docker-compose.staging.yml up -d --no-deps --scale audio-extract=2 audio-extract
          sleep 30
          docker-compose -f docker-compose.staging.yml up -d --no-deps --remove-orphans audio-extract
          
          # Health check
          sleep 10
          curl -f http://localhost:8081/health || exit 1
          
          echo "Staging deployment successful!"
        EOF
    
    - name: Run smoke tests
      env:
        STAGING_URL: ${{ secrets.STAGING_URL }}
      run: |
        # Basic health check
        curl -f $STAGING_URL/health
        
        # Check specific endpoints
        curl -f $STAGING_URL/api/stats
        
        echo "Smoke tests passed!"
    
    - name: Deployment summary
      run: |
        echo "## Staging Deployment Successful" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Image deployed:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** staging" >> $GITHUB_STEP_SUMMARY
        echo "**Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  deploy-production:
    # Production deployment requires:
    # - Manual workflow dispatch with production environment
    # - Successful staging deployment (when applicable)
    needs: [deploy-staging]
    if: |
      always() && 
      github.event_name == 'workflow_dispatch' && 
      github.event.inputs.environment == 'production' &&
      (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped')
    runs-on: ubuntu-latest
    environment: production
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set image tag
      id: set-tag
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Use the provided tag for manual deployments
          echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        else
          # For automatic deployments, use the SHA from the build workflow
          echo "tag=sha-${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
        fi
    
    - name: Pre-deployment checks
      run: |
        echo "Running pre-deployment checks..."
        # Add any pre-deployment validation here
        # e.g., database migrations, config validation, etc.
    
    - name: Deploy to production
      env:
        DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
        DEPLOY_USER: ${{ secrets.PRODUCTION_USER }}
        DEPLOY_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
        IMAGE_TAG: ${{ steps.set-tag.outputs.tag }}
        GCS_BUCKET_NAME: ${{ secrets.GCS_BUCKET_NAME }}
        AUDIO_EXTRACT_FOLDER_ID: ${{ secrets.AUDIO_EXTRACT_FOLDER_ID }}
      run: |
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts
        
        # Deploy script
        ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST << EOF
          set -e
          cd /opt/audio-extract
          
          # Backup current config
          cp docker-compose.prod.yml docker-compose.prod.yml.backup
          
          # Pull latest config
          git pull origin main
          
          # Set environment variables
          export AUDIO_EXTRACT_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.tag }}"
          export GCS_BUCKET_NAME="${{ env.GCS_BUCKET_NAME }}"
          export AUDIO_EXTRACT_FOLDER_ID="${{ env.AUDIO_EXTRACT_FOLDER_ID }}"
          
          echo "Deploying image: \${AUDIO_EXTRACT_IMAGE}"
          
          # Pull new image
          docker pull \${AUDIO_EXTRACT_IMAGE}
          
          # Deploy with rolling update
          docker-compose -f docker-compose.prod.yml up -d --no-deps --scale audio-extract=2 audio-extract
          
          # Wait for new container to be healthy
          sleep 60
          
          # Remove old containers
          docker-compose -f docker-compose.prod.yml up -d --no-deps --remove-orphans audio-extract
          
          # Verify deployment
          sleep 10
          if ! curl -f http://localhost:8081/health; then
            echo "Health check failed! Rolling back..."
            cp docker-compose.prod.yml.backup docker-compose.prod.yml
            docker-compose -f docker-compose.prod.yml up -d
            exit 1
          fi
          
          # Clean up old images
          docker image prune -f
          
          echo "Production deployment successful!"
        EOF
    
    - name: Post-deployment verification
      env:
        PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
      run: |
        # Comprehensive health checks
        curl -f $PRODUCTION_URL/health
        
        # Verify all components
        health_response=$(curl -s $PRODUCTION_URL/health)
        echo "Health check response: $health_response"
        
        # Check if GCSfuse is mounted
        if [[ $(echo $health_response | jq -r '.components.storage.status') != "healthy" ]]; then
          echo "Storage component is not healthy!"
          exit 1
        fi
        
        echo "All post-deployment checks passed!"
    
    - name: Production deployment summary
      run: |
        echo "## Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Image deployed:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** production" >> $GITHUB_STEP_SUMMARY
        echo "**URL:** ${{ secrets.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
        echo "**Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Health Check Results" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
        curl -s ${{ secrets.PRODUCTION_URL }}/health | jq '.' >> $GITHUB_STEP_SUMMARY || echo "Failed to fetch health status" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY